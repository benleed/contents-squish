<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>EPUB TOC Depth Mapper</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    #tocList { margin-top: 20px; }
    ul { list-style: none; padding-left: 20px; }
    li { margin: 2px 0; }
  </style>
</head>
<body>
  <h1>EPUB TOC Depth Mapper</h1>
  <input type="file" id="fileInput" accept=".epub"><br><br>

  <label for="depthSlider">Max Depth: <span id="depthValue">1</span></label>
  <input type="range" id="depthSlider" min="1" max="10" value="1"><br><br>

  <button id="downloadBtn" disabled>Download Modified EPUB</button>

  <div style="display:flex; gap:50px;">
    <div>
      <h3>toc.ncx TOC</h3>
      <div id="tocList"></div>
    </div>
    <div id="tocXHTMLContainer">
      <h3>toc.xhtml TOC</h3>
      <div id="tocXHTMLList"></div>
    </div>
  </div>

  <script>
    let tocXML, navPoints, originalZip, tocPath, tocXHTMLPath, tocXHTMLDoc;
    let fileName = "book.epub";

    function parseNavPoints(node, depth = 1) {
      let arr = [];
      node.querySelectorAll(":scope > navPoint").forEach(np => {
        arr.push({
          depth,
          label: np.querySelector("navLabel > text")?.textContent || "Untitled",
          src: np.querySelector("content")?.getAttribute("src") || "",
          children: parseNavPoints(np, depth + 1)
        });
      });
      return arr;
    }

    function renderTOC(toc, maxDepth) {
      let ul = document.createElement("ul");
      toc.forEach(item => {
        if (item.depth <= maxDepth) {
          let li = document.createElement("li");
          li.textContent = item.label;
          ul.appendChild(li);
          if (item.children.length) {
            li.appendChild(renderTOC(item.children, maxDepth));
          }
        }
      });
      return ul;
    }

    // Parse toc.xhtml <nav> structure into a similar tree
    function parseTocXHTML(navElem, depth = 1) {
      let arr = [];
      let ol = navElem.querySelector(":scope > ol");
      if (!ol) return arr;
      ol.querySelectorAll(":scope > li").forEach(li => {
        let a = li.querySelector(":scope > a");
        let label = a ? a.textContent : "Untitled";
        let src = a ? a.getAttribute("href") : "";
        let children = [];
        let subNav = li.querySelector(":scope > ol");
        if (subNav) {
          children = parseTocXHTML({querySelector: sel => subNav.querySelector(sel)}, depth + 1);
        }
        arr.push({ depth, label, src, children });
      });
      return arr;
    }

    function renderTocXHTMLTree(toc, maxDepth) {
      let ul = document.createElement("ul");
      toc.forEach(item => {
        if (item.depth <= maxDepth) {
          let li = document.createElement("li");
          li.textContent = item.label;
          ul.appendChild(li);
          if (item.children.length) {
            li.appendChild(renderTocXHTMLTree(item.children, maxDepth));
          }
        }
      });
      return ul;
    }

    function rebuildTOCXML(toc, maxDepth, xmlDoc) {
      let createNavPoint = (item, id) => {
        let np = xmlDoc.createElement("navPoint");
        np.setAttribute("id", "navPoint-" + id);
        np.setAttribute("playOrder", id);
        let label = xmlDoc.createElement("navLabel");
        let text = xmlDoc.createElement("text");
        text.textContent = item.label;
        label.appendChild(text);
        np.appendChild(label);
        let content = xmlDoc.createElement("content");
        content.setAttribute("src", item.src);
        np.appendChild(content);

        let childId = id + 1;
        item.children.forEach(child => {
          if (child.depth <= maxDepth) {
            np.appendChild(createNavPoint(child, ++childId));
          }
        });
        return np;
      };

      let newDoc = xmlDoc.cloneNode(true);
      let navMap = newDoc.querySelector("navMap");
      navMap.innerHTML = "";
      let id = 1;
      toc.forEach(item => {
        if (item.depth <= maxDepth) {
          navMap.appendChild(createNavPoint(item, id++));
        }
      });
      return new XMLSerializer().serializeToString(newDoc);
    }

    function rebuildTOCXHTML(toc, maxDepth, xmlDoc) {
      let newDoc = xmlDoc.cloneNode(true);
      let nav = newDoc.querySelector('nav[epub\\:type="toc"], nav[role="doc-toc"]');
      if (!nav) return null;

      let ol = newDoc.createElement("ol");
      toc.forEach(item => {
        if (item.depth <= maxDepth) {
          let li = newDoc.createElement("li");
          let a = newDoc.createElement("a");
          a.setAttribute("href", item.src);
          a.textContent = item.label;
          li.appendChild(a);
          ol.appendChild(li);
        }
      });

      nav.innerHTML = "";
      nav.appendChild(ol);

      return new XMLSerializer().serializeToString(newDoc);
    }

    let tocXHTMLTree = null;
    document.getElementById("fileInput").addEventListener("change", async e => {
      const file = e.target.files[0];
      if (!file) return;

      fileName = file.name;
      originalZip = await JSZip.loadAsync(file);

      // Locate toc.ncx
      tocPath = Object.keys(originalZip.files).find(f => f.endsWith("toc.ncx"));
      if (!tocPath) {
        alert("No toc.ncx found in EPUB.");
        return;
      }

      let text = await originalZip.file(tocPath).async("string");
      tocXML = new DOMParser().parseFromString(text, "application/xml");
      navPoints = parseNavPoints(tocXML.querySelector("navMap"));

      // Locate toc.xhtml if present
      tocXHTMLPath = Object.keys(originalZip.files).find(f => f.toLowerCase().endsWith("toc.xhtml"));
      tocXHTMLTree = null;
      if (tocXHTMLPath) {
        let tocXHTMLText = await originalZip.file(tocXHTMLPath).async("string");
        tocXHTMLDoc = new DOMParser().parseFromString(tocXHTMLText, "application/xhtml+xml");
        // Find <nav epub:type="toc"> or <nav role="doc-toc">
        let nav = tocXHTMLDoc.querySelector('nav[epub\\:type="toc"], nav[role="doc-toc"]');
        if (nav) {
          tocXHTMLTree = parseTocXHTML(nav);
        }
      }

      let depth = parseInt(document.getElementById("depthSlider").value);
      document.getElementById("tocList").innerHTML = "";
      document.getElementById("tocList").appendChild(renderTOC(navPoints, depth));

      // Show toc.xhtml TOC if available
      let tocXHTMLContainer = document.getElementById("tocXHTMLContainer");
      if (tocXHTMLTree && tocXHTMLTree.length) {
        tocXHTMLContainer.style.display = "block";
        let tocXHTMLList = document.getElementById("tocXHTMLList");
        tocXHTMLList.innerHTML = "";
        tocXHTMLList.appendChild(renderTocXHTMLTree(tocXHTMLTree, depth));
      } else {
        tocXHTMLList.innerHTML = "Nothing found.";
        if (tocXHTMLPath)
          tocXHTMLList.innerHTML += "But the file toc.xhtml exists in the EPUB.";
        
      }

      document.getElementById("downloadBtn").disabled = false;
    });

    document.getElementById("depthSlider").addEventListener("input", e => {
      let depth = parseInt(e.target.value);
      document.getElementById("depthValue").textContent = depth;
      if (!navPoints) return;
      document.getElementById("tocList").innerHTML = "";
      document.getElementById("tocList").appendChild(renderTOC(navPoints, depth));

      // Update toc.xhtml TOC if available
      let tocXHTMLContainer = document.getElementById("tocXHTMLContainer");
      if (tocXHTMLTree && tocXHTMLTree.length) {
        tocXHTMLContainer.style.display = "block";
        let tocXHTMLList = document.getElementById("tocXHTMLList");
        tocXHTMLList.innerHTML = "";
        tocXHTMLList.appendChild(renderTocXHTMLTree(tocXHTMLTree, depth));
      } else {
        tocXHTMLContainer.style.display = "none";
      }
    });

    document.getElementById("downloadBtn").addEventListener("click", async () => {
      let depth = parseInt(document.getElementById("depthSlider").value);
      let newXML = rebuildTOCXML(navPoints, depth, tocXML);

      // Replace toc.ncx in ZIP
      originalZip.file(tocPath, newXML);

      // Replace toc.xhtml if present
      if (tocXHTMLPath && tocXHTMLDoc) {
        let newXHTML = rebuildTOCXHTML(navPoints, depth, tocXHTMLDoc);
        if (newXHTML) {
          originalZip.file(tocXHTMLPath, newXHTML);
        }
      }

      // Generate new EPUB (with compression)
      let newBlob = await originalZip.generateAsync({ type: "blob", compression: "DEFLATE" });
      let a = document.createElement("a");
      a.href = URL.createObjectURL(newBlob);
      a.download = fileName.replace(/\.epub$/i, "_modified.epub");
      a.click();
    });
  </script>
</body>
</html>
